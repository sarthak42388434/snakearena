<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Arena - Multiplayer Snake Game</title>
    <meta name="description" content="Play Snake Arena - a modern twist on the classic snake game. Control your snake, eat food, grow longer, and avoid collisions in this fun multiplayer experience.">
    <meta name="keywords" content="snake game, multiplayer snake, arena game, browser game, HTML5 game, canvas game">
    <meta name="author" content="Snake Arena Team">
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Poppins', sans-serif;
        }
        
        body {
            overflow: hidden;
            background-color: #131a33;
            color: white;
        }
        
        canvas {
            display: block;
        }
        
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            background-color: rgba(0, 0, 0, 0.8);
        }
        
        #home-screen {
            display: flex;
        }
        
        #game-screen {
            display: none;
        }
        
        #game-over-screen {
            display: none;
        }
        
        #multiplayer-lobby {
            display: none;
        }
        
        .menu-box {
            background: rgba(20, 30, 60, 0.9);
            border-radius: 12px;
            padding: 2rem;
            width: 90%;
            max-width: 500px;
            border: 2px solid #3498db;
            box-shadow: 0 0 20px rgba(52, 152, 219, 0.5);
        }
        
        .title {
            text-align: center;
            font-size: 2.5rem;
            font-weight: 800;
            margin-bottom: 1.5rem;
            background: linear-gradient(to right, #3498db, #9b59b6);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            filter: drop-shadow(0 2px 3px rgba(0, 0, 0, 0.3));
        }
        
        .input-field {
            width: 100%;
            padding: 0.75rem 1rem;
            margin-bottom: 1rem;
            border-radius: 8px;
            border: 2px solid #3498db;
            background-color: rgba(30, 40, 70, 0.6);
            color: white;
            font-size: 1rem;
        }
        
        .btn {
            width: 100%;
            padding: 0.75rem;
            margin-top: 1rem;
            border: none;
            border-radius: 8px;
            background: linear-gradient(to right, #3498db, #9b59b6);
            color: white;
            font-size: 1.25rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.5);
        }
        
        #score-container {
            position: absolute;
            top: 1rem;
            left: 1rem;
            display: flex;
            flex-direction: column;
            z-index: 5;
            background: rgba(20, 30, 60, 0.7);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            border: 1px solid #3498db;
        }
        
        .glow {
            animation: glow 1.5s ease-in-out infinite alternate;
        }
        
        @keyframes glow {
            from {
                text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #3498db, 0 0 20px #3498db;
            }
            to {
                text-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 30px #3498db, 0 0 40px #3498db;
            }
        }
        
        .controls-info {
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            background: rgba(20, 30, 60, 0.7);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-size: 0.875rem;
            border: 1px solid #3498db;
            z-index: 5;
        }
        
        #sound-toggle {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(20, 30, 60, 0.7);
            padding: 0.5rem;
            border-radius: 50%;
            cursor: pointer;
            z-index: 5;
            border: 1px solid #3498db;
            font-size: 1.2rem;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Content Pages */
        .content-page {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(19, 26, 51, 0.95);
            z-index: 20;
            overflow-y: auto;
            padding: 2rem 1rem;
        }
        
        .page-container {
            max-width: 800px;
            margin: 0 auto;
            padding: 1rem;
            background: rgba(20, 30, 60, 0.7);
            border-radius: 12px;
            border: 1px solid #3498db;
        }
        
        .page-header {
            margin-bottom: 2rem;
            text-align: center;
        }
        
        .close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(20, 30, 60, 0.7);
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.5rem;
            border: 1px solid #3498db;
            z-index: 21;
        }
        
        /* Navigation */
        #main-nav {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            padding: 1rem;
            z-index: 15;
        }
        
        .nav-link {
            color: white;
            text-decoration: none;
            margin: 0 1rem;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            background: rgba(20, 30, 60, 0.7);
            transition: all 0.2s;
        }
        
        .nav-link:hover {
            background: rgba(52, 152, 219, 0.5);
        }
        
        /* Footer */
        #main-footer {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(20, 30, 60, 0.7);
            text-align: center;
            padding: 1rem;
            font-size: 0.875rem;
            z-index: 15;
        }
        
        /* Blog */
        .blog-post {
            margin-bottom: 2rem;
            padding-bottom: 2rem;
            border-bottom: 1px solid rgba(52, 152, 219, 0.5);
        }
        
        .blog-post:last-child {
            border-bottom: none;
        }
        
        /* Multiplayer Lobby */
        .player-list {
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 1rem;
            border: 1px solid rgba(52, 152, 219, 0.5);
            border-radius: 8px;
            padding: 0.5rem;
        }
        
        .player-item {
            display: flex;
            align-items: center;
            padding: 0.5rem;
            border-bottom: 1px solid rgba(52, 152, 219, 0.3);
        }
        
        .player-item:last-child {
            border-bottom: none;
        }
        
        .player-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-right: 0.5rem;
        }
        
        /* Power-up indicators */
        .power-up-indicator {
            position: absolute;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(20, 30, 60, 0.7);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-size: 0.875rem;
            border: 1px solid #3498db;
            z-index: 5;
            display: flex;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .power-up-icon {
            margin-right: 0.5rem;
            font-size: 1.2rem;
        }
        
        /* Leaderboard */
        #leaderboard {
            position: absolute;
            top: 1rem;
            right: 5rem;
            background: rgba(20, 30, 60, 0.7);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-size: 0.875rem;
            border: 1px solid #3498db;
            z-index: 5;
            min-width: 150px;
        }
        
        .leaderboard-title {
            text-align: center;
            font-weight: bold;
            margin-bottom: 0.5rem;
            border-bottom: 1px solid rgba(52, 152, 219, 0.5);
            padding-bottom: 0.25rem;
        }
        
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.25rem;
        }
    </style>
</head>
<body class="bg-gray-900 text-white">
    <!-- Navigation -->
    <nav id="main-nav">
        <a href="#" class="nav-link home-link">Home</a>
        <a href="#" class="nav-link" data-page="about">About</a>
        <a href="#" class="nav-link" data-page="blog">Blog</a>
        <a href="#" class="nav-link" data-page="contact">Contact</a>
        <a href="#" class="nav-link" data-page="privacy">Privacy</a>
    </nav>
    
    <!-- Footer -->
    <footer id="main-footer">
        <div>&copy; 2023 Snake Arena. All Rights Reserved.</div>
        <div class="mt-2">
            <a href="#" class="text-blue-400 hover:text-blue-300 mx-2 home-link">Home</a>
            <a href="#" class="text-blue-400 hover:text-blue-300 mx-2" data-page="about">About</a>
            <a href="#" class="text-blue-400 hover:text-blue-300 mx-2" data-page="blog">Blog</a>
            <a href="#" class="text-blue-400 hover:text-blue-300 mx-2" data-page="contact">Contact</a>
            <a href="#" class="text-blue-400 hover:text-blue-300 mx-2" data-page="privacy">Privacy</a>
        </div>
    </footer>
    
    <!-- Game Container -->
    <div id="game-container">
        <!-- Home Screen -->
        <div id="home-screen" class="screen">
            <div class="menu-box">
                <h1 class="title">Snake Arena</h1>
                <input type="text" id="nickname-input" class="input-field" placeholder="Enter your nickname" maxlength="15">
                <div class="mb-4 text-center">
                    <p>Select Snake Color:</p>
                    <div class="flex justify-center mt-2 space-x-2">
                        <div class="w-8 h-8 bg-red-500 rounded-full cursor-pointer color-option" data-color="#ef4444"></div>
                        <div class="w-8 h-8 bg-blue-500 rounded-full cursor-pointer color-option" data-color="#3b82f6"></div>
                        <div class="w-8 h-8 bg-green-500 rounded-full cursor-pointer color-option" data-color="#22c55e"></div>
                        <div class="w-8 h-8 bg-yellow-500 rounded-full cursor-pointer color-option" data-color="#eab308"></div>
                        <div class="w-8 h-8 bg-purple-500 rounded-full cursor-pointer color-option" data-color="#a855f7"></div>
                    </div>
                </div>
                <div class="mb-4 text-center">
                    <p>Game Mode:</p>
                    <div class="flex justify-center mt-2 space-x-4">
                        <label class="flex items-center cursor-pointer">
                            <input type="radio" name="game-mode" value="single" checked class="mr-2">
                            <span>Single Player</span>
                        </label>
                        <label class="flex items-center cursor-pointer">
                            <input type="radio" name="game-mode" value="multi" class="mr-2">
                            <span>Multiplayer</span>
                        </label>
                    </div>
                </div>
                <button id="play-btn" class="btn">
                    <i class="fas fa-play mr-2"></i> PLAY
                </button>
                <div class="mt-4 text-sm text-center text-gray-300">
                    <h3 class="text-white mb-1 font-bold">How to Play:</h3>
                    <p><i class="fas fa-mouse-pointer mr-1"></i> Move with your mouse</p>
                    <p><i class="fas fa-keyboard mr-1"></i> Or use arrow keys</p>
                    <p><i class="fas fa-rocket mr-1"></i> Hold SPACE to boost</p>
                    <p class="mt-2">Eat colorful food to grow longer and score points!</p>
                    <p class="mt-1">Look for special foods with unique effects!</p>
                </div>
            </div>
        </div>
        
        <!-- Multiplayer Lobby -->
        <div id="multiplayer-lobby" class="screen">
            <div class="menu-box">
                <h1 class="title">Multiplayer Lobby</h1>
                <div class="mb-4">
                    <p class="text-center mb-2">Players in Lobby:</p>
                    <div id="player-list" class="player-list">
                        <!-- Players will be added here dynamically -->
                    </div>
                </div>
                <div class="flex space-x-2">
                    <button id="start-multiplayer-btn" class="btn flex-1">
                        <i class="fas fa-play mr-2"></i> START GAME
                    </button>
                    <button id="leave-lobby-btn" class="btn flex-1 bg-red-500">
                        <i class="fas fa-arrow-left mr-2"></i> LEAVE
                    </button>
                </div>
                <div class="mt-4 text-sm text-center text-gray-300">
                    <p>Waiting for players to join...</p>
                    <p class="mt-2">Game will start when all players are ready</p>
                </div>
            </div>
        </div>
        
        <!-- Game Screen -->
        <div id="game-screen">
            <div id="score-container">
                <div>Score: <span id="current-score">0</span></div>
                <div>Best: <span id="best-score">0</span></div>
            </div>
            <div id="sound-toggle">
                <i class="fas fa-volume-up"></i>
            </div>
            <div class="controls-info">
                <div><i class="fas fa-mouse-pointer mr-1"></i> Mouse: steer</div>
                <div><i class="fas fa-arrows-alt mr-1"></i> Arrows: move</div>
                <div><i class="fas fa-rocket mr-1"></i> Space: boost</div>
            </div>
            <div id="power-up-indicator" class="power-up-indicator">
                <span id="power-up-icon" class="power-up-icon"><i class="fas fa-bolt"></i></span>
                <span id="power-up-text">Speed Boost Active!</span>
            </div>
            <div id="leaderboard" style="display: none;">
                <div class="leaderboard-title">Leaderboard</div>
                <div id="leaderboard-items">
                    <!-- Leaderboard items will be added here dynamically -->
                </div>
            </div>
            <canvas id="game-canvas"></canvas>
        </div>
        
        <!-- Game Over Screen -->
        <div id="game-over-screen" class="screen">
            <div class="menu-box">
                <h1 class="title">Game Over</h1>
                <div class="text-center mb-4">
                    <p class="text-xl">Your score: <span id="final-score" class="font-bold glow">0</span></p>
                    <p class="mt-2">Best score: <span id="best-score-final" class="font-bold">0</span></p>
                </div>
                <button id="play-again-btn" class="btn">
                    <i class="fas fa-redo mr-2"></i> PLAY AGAIN
                </button>
                <button id="home-btn" class="btn mt-2 bg-blue-500">
                    <i class="fas fa-home mr-2"></i> BACK TO HOME
                </button>
            </div>
        </div>
        
        <!-- About Page -->
        <div id="about-page" class="content-page">
            <button class="close-btn">&times;</button>
            <div class="page-container">
                <div class="page-header">
                    <h1 class="text-3xl font-bold mb-2">About Snake Arena</h1>
                    <div class="w-20 h-1 bg-blue-500 mx-auto"></div>
                </div>
                <div class="page-content">
                    <h2 class="text-2xl font-bold mb-3">Our Story</h2>
                    <p class="mb-4">
                        Snake Arena is a modern interpretation of the classic snake game that has entertained generations 
                        of players. Developed by a team of passionate game developers, our mission is to bring the joy of 
                        simple yet addictive gameplay to a new audience while honoring the legacy of this iconic game.
                    </p>
                    
                    <h2 class="text-2xl font-bold mb-3">Game Features</h2>
                    <ul class="list-disc list-inside mb-4">
                        <li class="mb-2">Smooth, responsive controls for both mouse and keyboard</li>
                        <li class="mb-2">Beautiful visual effects and dynamic environments</li>
                        <li class="mb-2">Speed boost mechanism for strategic gameplay</li>
                        <li class="mb-2">Customizable snake appearance</li>
                        <li class="mb-2">High score tracking to challenge yourself</li>
                        <li class="mb-2">Special power-up foods with unique effects</li>
                        <li class="mb-2">Multiplayer mode to compete with friends</li>
                    </ul>
                    
                    <h2 class="text-2xl font-bold mb-3">How to Play</h2>
                    <p class="mb-4">
                        Control your snake to eat the colorful food pellets scattered around the arena. Each food item you 
                        consume will make your snake grow longer. The longer your snake, the higher your score! But be careful - 
                        if your snake's head collides with any part of its body, it's game over!
                    </p>
                    <p class="mb-4">
                        Use your mouse to steer the snake, or alternatively, use the arrow keys on your keyboard. Hold the 
                        space bar to activate a temporary speed boost, but be aware that boosting causes your snake to shrink 
                        over time, lowering your score.
                    </p>
                    
                    <h2 class="text-2xl font-bold mb-3">Special Foods</h2>
                    <p class="mb-4">
                        Look out for special food items that provide unique effects:
                    </p>
                    <ul class="list-disc list-inside mb-4">
                        <li class="mb-2">Star Food (Gold): Gives double points and growth</li>
                        <li class="mb-2">Speed Food (Blue): Temporary speed boost without shrinking</li>
                        <li class="mb-2">Shield Food (Purple): Temporary immunity to self-collision</li>
                        <li class="mb-2">Ghost Food (White): Allows passing through other snakes in multiplayer</li>
                        <li class="mb-2">Shrink Food (Red): Reduces your size but maintains your score</li>
                    </ul>
                    
                    <h2 class="text-2xl font-bold mb-3">Multiplayer Mode</h2>
                    <p class="mb-4">
                        Challenge your friends in multiplayer mode! Compete for food, avoid other players, and try to become
                        the longest snake in the arena. You can also trap other players by encircling them, but be careful
                        not to collide with them!
                    </p>
                    
                    <h2 class="text-2xl font-bold mb-3">For All Ages</h2>
                    <p>
                        Snake Arena is designed to be accessible and entertaining for players of all ages. Whether you're 
                        looking for a quick game during a break or an engaging experience to test your reflexes and strategy, 
                        Snake Arena offers a perfect blend of challenge and fun.
                    </p>
                </div>
            </div>
        </div>
        
        <!-- Blog Page -->
        <div id="blog-page" class="content-page">
            <button class="close-btn">&times;</button>
            <div class="page-container">
                <div class="page-header">
                    <h1 class="text-3xl font-bold mb-2">Snake Arena Blog</h1>
                    <div class="w-20 h-1 bg-blue-500 mx-auto"></div>
                </div>
                <div class="page-content">
                    <div class="blog-post">
                        <h2 class="text-2xl font-bold mb-2">The Evolution of Snake Games: From Nokia to Modern Browsers</h2>
                        <p class="text-sm text-gray-400 mb-3">Posted on April 15, 2023</p>
                        
                        <p class="mb-3">
                            The snake game has a rich history dating back to the 1970s arcade game called "Blockade." However, 
                            most people first encountered the game on their Nokia mobile phones in the late 1990s. This 
                            simple yet addictive game became a cultural phenomenon, helping to pass time during commutes or 
                            while waiting for appointments.
                        </p>
                        
                        <h3 class="text-xl font-bold mt-4 mb-2">The Original Snake</h3>
                        <p class="mb-3">
                            The original mobile version of Snake was programmed by Taneli Armanto, a design engineer at Nokia. 
                            It first appeared on the Nokia 6110 in 1997 and quickly became one of the most played video games 
                            in the world. The game's simplicity was its strength - players controlled a snake that grew longer 
                            as it consumed food, with the game ending if the snake collided with itself or the walls.
                        </p>
                        
                        <h3 class="text-xl font-bold mt-4 mb-2">Web-Based Revival</h3>
                        <p class="mb-3">
                            With the rise of HTML5 and browser capabilities, snake games found a new home on the web. 
                            Developers began creating more sophisticated versions with enhanced graphics, multiplayer 
                            capabilities, and additional gameplay mechanics like the boost feature seen in Snake Arena.
                        </p>
                        
                        <h3 class="text-xl font-bold mt-4 mb-2">Modern Innovations</h3>
                        <p class="mb-3">
                            Today's snake games incorporate features that were unimaginable in the Nokia era. Real-time 
                            multiplayer, custom skins, special abilities, and complex environments have transformed the 
                            simple concept into deep, strategic experiences. Snake Arena builds on this legacy, offering 
                            smooth gameplay and modern visuals while maintaining the core mechanics that made the original 
                            so compelling.
                        </p>
                        
                        <h3 class="text-xl font-bold mt-4 mb-2">Looking Forward</h3>
                        <p>
                            As browser technology continues to advance, we can expect snake games to evolve further. 
                            At Snake Arena, we're committed to preserving the essence of the classic game while exploring 
                            new features and improvements. We're excited to be part of this gaming legacy and look forward 
                            to bringing you more updates and enhancements in the future.
                        </p>
                    </div>
                    
                    <div class="blog-post">
                        <h2 class="text-2xl font-bold mb-2">5 Strategies to Maximize Your Score in Snake Arena</h2>
                        <p class="text-sm text-gray-400 mb-3">Posted on May 2, 2023</p>
                        
                        <p class="mb-3">
                            Looking to climb the Snake Arena leaderboards? Here are five proven strategies that can help
                            you achieve higher scores and outmaneuver your competition.
                        </p>
                        
                        <h3 class="text-xl font-bold mt-4 mb-2">1. Master the Boost</h3>
                        <p class="mb-3">
                            The boost feature is a double-edged sword. Use it strategically to quickly reach food or escape
                            tight situations, but be aware that prolonged boosting will shrink your snake and lower your score.
                            Short, calculated bursts are typically more effective than extended boosts.
                        </p>
                        
                        <h3 class="text-xl font-bold mt-4 mb-2">2. Patrol the Edges</h3>
                        <p class="mb-3">
                            Moving along the edges of the arena can be a safer strategy, as it reduces the directions from
                            which you might accidentally collide with your own body. Just be careful not to trap yourself
                            in a corner!
                        </p>
                        
                        <h3 class="text-xl font-bold mt-4 mb-2">3. Plan Your Path</h3>
                        <p>
                            Always think several moves ahead. Create efficient routes to collect multiple food items without
                            crossing your own path. This forward thinking is what separates average players from top scorers.
                        </p>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Contact Page -->
        <div id="contact-page" class="content-page">
            <button class="close-btn">&times;</button>
            <div class="page-container">
                <div class="page-header">
                    <h1 class="text-3xl font-bold mb-2">Contact Us</h1>
                    <div class="w-20 h-1 bg-blue-500 mx-auto"></div>
                </div>
                <div class="page-content">
                    <p class="text-center mb-6">
                        Have questions, suggestions, or feedback about Snake Arena? We'd love to hear from you!
                    </p>
                    
                    <div class="max-w-md mx-auto">
                        <form id="contact-form" class="space-y-4">
                            <div>
                                <label for="name" class="block mb-1">Your Name</label>
                                <input type="text" id="name" class="input-field" required>
                            </div>
                            
                            <div>
                                <label for="email" class="block mb-1">Email Address</label>
                                <input type="email" id="email" class="input-field" required>
                            </div>
                            
                            <div>
                                <label for="subject" class="block mb-1">Subject</label>
                                <input type="text" id="subject" class="input-field" required>
                            </div>
                            
                            <div>
                                <label for="message" class="block mb-1">Message</label>
                                <textarea id="message" class="input-field" rows="5" required></textarea>
                            </div>
                            
                            <button type="submit" class="btn">
                                <i class="fas fa-paper-plane mr-2"></i> Send Message
                            </button>
                        </form>
                        
                        <div id="contact-success" class="mt-4 p-3 bg-green-800 rounded-md text-center hidden">
                            Thank you for your message! We'll get back to you soon.
                        </div>
                    </div>
                    
                    <div class="mt-8 text-center">
                        <h3 class="text-xl font-bold mb-3">Connect With Us</h3>
                        <div class="flex justify-center space-x-4">
                            <a href="#" class="text-2xl hover:text-blue-400"><i class="fab fa-twitter"></i></a>
                            <a href="#" class="text-2xl hover:text-blue-400"><i class="fab fa-facebook"></i></a>
                            <a href="#" class="text-2xl hover:text-blue-400"><i class="fab fa-instagram"></i></a>
                            <a href="#" class="text-2xl hover:text-blue-400"><i class="fab fa-github"></i></a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Privacy Policy Page -->
        <div id="privacy-page" class="content-page">
            <button class="close-btn">&times;</button>
            <div class="page-container">
                <div class="page-header">
                    <h1 class="text-3xl font-bold mb-2">Privacy Policy</h1>
                    <div class="w-20 h-1 bg-blue-500 mx-auto"></div>
                </div>
                <div class="page-content">
                    <p class="mb-4">
                        Last updated: June 1, 2023
                    </p>
                    
                    <h2 class="text-xl font-bold mb-2">Introduction</h2>
                    <p class="mb-4">
                        Snake Arena ("we," "us," or "our") is committed to protecting your privacy. This Privacy Policy explains how we collect, use, and safeguard your information when you visit our website and play our game.
                    </p>
                    
                    <h2 class="text-xl font-bold mb-2">Information We Collect</h2>
                    <p class="mb-4">
                        <strong>Personal Information:</strong> We collect information that you voluntarily provide when contacting us, such as your name and email address.
                    </p>
                    <p class="mb-4">
                        <strong>Game Data:</strong> We collect non-personal information related to your gameplay, including scores, game duration, and in-game actions to improve our services.
                    </p>
                    <p class="mb-4">
                        <strong>Cookies:</strong> We use cookies to enhance your experience, analyze site usage, and assist in our marketing efforts.
                    </p>
                    
                    <h2 class="text-xl font-bold mb-2">How We Use Your Information</h2>
                    <ul class="list-disc list-inside mb-4">
                        <li class="mb-2">To provide and maintain our Service</li>
                        <li class="mb-2">To notify you about changes to our Service</li>
                        <li class="mb-2">To allow you to participate in interactive features of our Service</li>
                        <li class="mb-2">To provide customer support</li>
                        <li class="mb-2">To gather analysis to improve our Service</li>
                        <li class="mb-2">To monitor the usage of our Service</li>
                    </ul>
                    
                    <h2 class="text-xl font-bold mb-2">Data Security</h2>
                    <p class="mb-4">
                        The security of your data is important to us, but remember that no method of transmission over the Internet or method of electronic storage is 100% secure. While we strive to use commercially acceptable means to protect your Personal Information, we cannot guarantee its absolute security.
                    </p>
                    
                    <h2 class="text-xl font-bold mb-2">Third-Party Services</h2>
                    <p class="mb-4">
                        We may employ third-party companies and individuals to facilitate our Service, provide the Service on our behalf, perform Service-related services, or assist us in analyzing how our Service is used. These third parties may have access to your Personal Information only to perform these tasks on our behalf and are obligated not to disclose or use it for any other purpose.
                    </p>
                    
                    <h2 class="text-xl font-bold mb-2">Advertising</h2>
                    <p class="mb-4">
                        We may use third-party advertising companies to serve ads when you visit our website. These companies may use information about your visits to this and other websites to provide advertisements about goods and services that may be of interest to you.
                    </p>
                    
                    <h2 class="text-xl font-bold mb-2">Children's Privacy</h2>
                    <p class="mb-4">
                        Our Service does not address anyone under the age of 13. We do not knowingly collect personally identifiable information from children under 13. If we discover that a child under 13 has provided us with personal information, we immediately delete this from our servers.
                    </p>
                    
                    <h2 class="text-xl font-bold mb-2">Changes to This Privacy Policy</h2>
                    <p class="mb-4">
                        We may update our Privacy Policy from time to time. We will notify you of any changes by posting the new Privacy Policy on this page and updating the "Last updated" date.
                    </p>
                    
                    <h2 class="text-xl font-bold mb-2">Contact Us</h2>
                    <p>
                        If you have any questions about this Privacy Policy, please contact us through the information provided on our Contact page.
                    </p>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Game configuration
        const config = {
            worldSize: 3000,         // Size of the game world
            initialSnakeLength: 10,  // Initial length of the snake
            foodAmount: 200,         // Number of food pellets in the world
            foodSize: 8,             // Size of food pellets
            gridSize: 50,            // Size of grid squares
            snakeSegmentSize: 15,    // Size of snake segments
            snakeSegmentSpacing: 5,  // Space between snake segments
            snakeSpeed: 3,           // Normal snake speed
            boostSpeed: 6,           // Boosted snake speed
            shrinkRate: 0.25,        // Rate at which snake shrinks while boosting
            growRate: 3,             // How much the snake grows when eating food
            sounds: true,            // Sound effects enabled by default
            specialFoodChance: 0.15, // Chance of spawning special food (15%)
            powerUpDuration: 10,     // Duration of power-ups in seconds
            multiplayerEnabled: false, // Multiplayer mode flag
            maxPlayers: 8,           // Maximum number of players in multiplayer
        };
        
        // Game state
        let gameState = {
            running: false,
            score: 0,
            bestScore: localStorage.getItem('snakeArenaBestScore') || 0,
            nickname: '',
            snakeColor: '#3b82f6', // Default snake color
            gameMode: 'single',    // Default game mode
            activePowerUp: null,   // Current active power-up
            powerUpTimer: null,    // Timer for power-up duration
            players: [],           // List of players in multiplayer
            isMultiplayer: false,  // Is current game multiplayer
        };
        
        // DOM Elements
        const homeScreen = document.getElementById('home-screen');
        const gameScreen = document.getElementById('game-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const multiplayerLobby = document.getElementById('multiplayer-lobby');
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const nicknameInput = document.getElementById('nickname-input');
        const playBtn = document.getElementById('play-btn');
        const playAgainBtn = document.getElementById('play-again-btn');
        const homeBtn = document.getElementById('home-btn');
        const startMultiplayerBtn = document.getElementById('start-multiplayer-btn');
        const leaveLobbyBtn = document.getElementById('leave-lobby-btn');
        const currentScoreElement = document.getElementById('current-score');
        const bestScoreElement = document.getElementById('best-score');
        const finalScoreElement = document.getElementById('final-score');
        const bestScoreFinalElement = document.getElementById('best-score-final');
        const soundToggle = document.getElementById('sound-toggle');
        const colorOptions = document.querySelectorAll('.color-option');
        const gameModeOptions = document.querySelectorAll('input[name="game-mode"]');
        const playerList = document.getElementById('player-list');
        const powerUpIndicator = document.getElementById('power-up-indicator');
        const powerUpIcon = document.getElementById('power-up-icon');
        const powerUpText = document.getElementById('power-up-text');
        const leaderboard = document.getElementById('leaderboard');
        const leaderboardItems = document.getElementById('leaderboard-items');
        
        // Sound effects - Using royalty-free sounds
        const sounds = {
            eat: new Audio('https://assets.codepen.io/39255/blip.mp3'),
            boost: new Audio('https://assets.codepen.io/39255/switch.mp3'),
            gameOver: new Audio('https://assets.codepen.io/39255/SynthChime5.mp3'),
            powerUp: new Audio('https://assets.codepen.io/39255/powerUp.mp3'),
            powerDown: new Audio('https://assets.codepen.io/39255/powerDown.mp3')
        };
        
        // Initialize
        let snake;
        let foods = [];
        let otherSnakes = []; // For multiplayer
        let camera = { x: 0, y: 0 };
        let keys = {};
        let lastTime = 0;
        let boosting = false;
        
        // Set canvas size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        // Random helpers
        function randomRange(min, max) {
            return Math.random() * (max - min) + min;
        }
        
        function randomColor() {
            const colors = [
                '#ef4444', '#f97316', '#eab308', '#22c55e', 
                '#3b82f6', '#6366f1', '#a855f7', '#ec4899'
            ];
            return colors[Math.floor(Math.random() * colors.length)];
        }
        
        // Food types and their effects
        const foodTypes = {
            regular: {
                name: 'Regular',
                color: '', // Random color
                growAmount: config.growRate,
                scoreMultiplier: 1,
                effect: null,
                chance: 0.85 // 85% chance of regular food
            },
            star: {
                name: 'Star',
                color: '#FFD700', // Gold
                growAmount: config.growRate * 2,
                scoreMultiplier: 2,
                effect: null,
                chance: 0.05 // 5% chance
            },
            speed: {
                name: 'Speed',
                color: '#00BFFF', // Deep sky blue
                growAmount: config.growRate,
                scoreMultiplier: 1,
                effect: 'speed',
                chance: 0.025 // 2.5% chance
            },
            shield: {
                name: 'Shield',
                color: '#9932CC', // Dark orchid
                growAmount: config.growRate,
                scoreMultiplier: 1,
                effect: 'shield',
                chance: 0.025 // 2.5% chance
            },
            ghost: {
                name: 'Ghost',
                color: '#F8F8FF', // Ghost white
                growAmount: config.growRate,
                scoreMultiplier: 1,
                effect: 'ghost',
                chance: 0.025 // 2.5% chance
            },
            shrink: {
                name: 'Shrink',
                color: '#DC143C', // Crimson
                growAmount: -5, // Shrinks the snake
                scoreMultiplier: 1,
                effect: null,
                chance: 0.025 // 2.5% chance
            }
        };
        
        // Get random food type based on chances
        function getRandomFoodType() {
            const rand = Math.random();
            let cumulativeChance = 0;
            
            for (const type in foodTypes) {
                cumulativeChance += foodTypes[type].chance;
                if (rand < cumulativeChance) {
                    return type;
                }
            }
            
            return 'regular'; // Fallback
        }
        
        // Snake class
        class Snake {
            constructor(x, y, color, isPlayer = true, nickname = '') {
                this.segments = [];
                this.targetLength = config.initialSnakeLength;
                this.velocity = { x: 0, y: 0 };
                this.speed = config.snakeSpeed;
                this.color = color;
                this.head = { x, y };
                this.angle = 0;
                this.boosting = false;
                this.isPlayer = isPlayer; // Is this the player's snake
                this.nickname = nickname;
                this.score = 0;
                this.effects = {
                    shield: false,
                    speed: false,
                    ghost: false
                };
                
                // Initialize segments
                for (let i = 0; i < this.targetLength; i++) {
                    this.segments.push({ 
                        x: x - i * config.snakeSegmentSpacing, 
                        y, 
                        size: config.snakeSegmentSize
                    });
                }
            }
            
            update(dt, mouseX, mouseY) {
                // Calculate angle to mouse/direction
                let targetX, targetY;
                
                if (this.isPlayer) {
                    if (mouseX !== undefined && mouseY !== undefined) {
                        // Mouse control
                        targetX = mouseX - canvas.width / 2 + camera.x;
                        targetY = mouseY - canvas.height / 2 + camera.y;
                    } else {
                        // Keyboard control
                        const dx = (keys.ArrowRight ? 1 : 0) - (keys.ArrowLeft ? 1 : 0);
                        const dy = (keys.ArrowDown ? 1 : 0) - (keys.ArrowUp ? 1 : 0);
                        
                        if (dx !== 0 || dy !== 0) {
                            targetX = this.head.x + dx * 100;
                            targetY = this.head.y + dy * 100;
                        } else {
                            targetX = this.head.x + Math.cos(this.angle) * 100;
                            targetY = this.head.y + Math.sin(this.angle) * 100;
                        }
                    }
                } else {
                    // AI control for non-player snakes
                    // Simple AI: move toward the nearest food
                    let nearestFood = null;
                    let minDistance = Infinity;
                    
                    for (const food of foods) {
                        const dx = food.x - this.head.x;
                        const dy = food.y - this.head.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearestFood = food;
                        }
                    }
                    
                    if (nearestFood) {
                        targetX = nearestFood.x;
                        targetY = nearestFood.y;
                    } else {
                        // Random movement if no food is found
                        targetX = this.head.x + Math.cos(this.angle) * 100;
                        targetY = this.head.y + Math.sin(this.angle) * 100;
                    }
                    
                    // Random boosting for AI
                    if (Math.random() < 0.01) {
                        this.boosting = !this.boosting;
                    }
                }
                
                this.angle = Math.atan2(targetY - this.head.y, targetX - this.head.x);
                
                // Update speed based on boost state and effects
                if (this.effects.speed) {
                    this.speed = config.boostSpeed * 1.2; // 20% faster than boost
                } else {
                    this.speed = this.boosting ? config.boostSpeed : config.snakeSpeed;
                }
                
                // Update velocity
                this.velocity.x = Math.cos(this.angle) * this.speed;
                this.velocity.y = Math.sin(this.angle) * this.speed;
                
                // Move head
                this.head.x += this.velocity.x;
                this.head.y += this.velocity.y;
                
                // Update first segment to match head
                if (this.segments.length > 0) {
                    this.segments[0].x = this.head.x;
                    this.segments[0].y = this.head.y;
                }
                
                // Update body segments to follow the segment in front
                for (let i = 1; i < this.segments.length; i++) {
                    const prev = this.segments[i-1];
                    const curr = this.segments[i];
                    
                    const dx = prev.x - curr.x;
                    const dy = prev.y - curr.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > config.snakeSegmentSpacing) {
                        const angle = Math.atan2(dy, dx);
                        const moveX = Math.cos(angle) * (distance - config.snakeSegmentSpacing);
                        const moveY = Math.sin(angle) * (distance - config.snakeSegmentSpacing);
                        
                        curr.x += moveX;
                        curr.y += moveY;
                    }
                }
                
                // Handle boosting and shrinking (only if no speed effect)
                if (this.boosting && !this.effects.speed && this.segments.length > 5) {
                    this.targetLength -= config.shrinkRate;
                    if (this.segments.length > Math.floor(this.targetLength)) {
                        this.segments.pop();
                        if (this.isPlayer) {
                            updateScore(this.segments.length);
                        } else {
                            this.score = this.segments.length;
                        }
                    }
                }
                
                // Add segments if growing
                while (this.segments.length < Math.floor(this.targetLength)) {
                    const lastSegment = this.segments[this.segments.length - 1];
                    this.segments.push({ 
                        x: lastSegment.x, 
                        y: lastSegment.y,
                        size: config.snakeSegmentSize
                    });
                }
                
                // Check boundaries (optional)
                const margin = 50;
                if (this.head.x < -config.worldSize/2 + margin) this.head.x = -config.worldSize/2 + margin;
                if (this.head.x > config.worldSize/2 - margin) this.head.x = config.worldSize/2 - margin;
                if (this.head.y < -config.worldSize/2 + margin) this.head.y = -config.worldSize/2 + margin;
                if (this.head.y > config.worldSize/2 - margin) this.head.y = config.worldSize/2 - margin;
                
                // Update camera to follow player's snake head
                if (this.isPlayer) {
                    camera.x = this.head.x;
                    camera.y = this.head.y;
                }
            }
            
            grow(amount) {
                this.targetLength += amount || config.growRate;
            }
            
            checkCollision(otherSnakes = []) {
                // Skip collision check if shield effect is active
                if (this.effects.shield) return false;
                
                // Check collision with self
                if (this.segments.length > 10) { // Allow small snakes to cross themselves
                    const headX = this.head.x;
                    const headY = this.head.y;
                    
                    for (let i = 10; i < this.segments.length; i++) {
                        const segment = this.segments[i];
                        const dx = headX - segment.x;
                        const dy = headY - segment.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // Hit body if closer than 3/4 of segment size
                        if (distance < segment.size * 0.75) {
                            return true; // Collision detected
                        }
                    }
                }
                
                // Check collision with other snakes in multiplayer
                if (gameState.isMultiplayer && !this.effects.ghost) {
                    const headX = this.head.x;
                    const headY = this.head.y;
                    
                    for (const otherSnake of otherSnakes) {
                        // Skip self
                        if (otherSnake === this) continue;
                        
                        for (const segment of otherSnake.segments) {
                            const dx = headX - segment.x;
                            const dy = headY - segment.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            // Hit other snake if closer than 3/4 of segment size
                            if (distance < (segment.size + this.segments[0].size) * 0.5) {
                                return true; // Collision detected
                            }
                        }
                    }
                }
                
                return false; // No collision
            }
            
            draw(ctx) {
                // Draw trail glow
                ctx.save();
                for (let i = this.segments.length - 1; i >= 0; i -= 5) {
                    const segment = this.segments[i];
                    ctx.beginPath();
                    ctx.arc(segment.x, segment.y, segment.size * 0.8, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
                    ctx.shadowColor = this.color;
                    ctx.shadowBlur = 10;
                    ctx.fill();
                }
                ctx.restore();
                
                // Draw each segment
                for (let i = this.segments.length - 1; i >= 0; i--) {
                    const segment = this.segments[i];
                    const ratio = i / this.segments.length;
                    const size = segment.size * (i === 0 ? 1 : (0.85 + ratio * 0.15));
                    
                    // Draw circle segment
                    ctx.beginPath();
                    ctx.arc(segment.x, segment.y, size, 0, Math.PI * 2);
                    
                    // Color gradient from head to tail
                    if (i === 0) {
                        // Head color
                        ctx.fillStyle = this.color;
                    } else {
                        // Body color with gradient
                        let alpha = 0.7 + 0.3 * (1 - ratio);
                        
                        // Apply visual effects
                        if (this.effects.shield) {
                            // Shield effect - add blue glow
                            ctx.shadowColor = '#9932CC';
                            ctx.shadowBlur = 15;
                        } else if (this.effects.ghost) {
                            // Ghost effect - make semi-transparent
                            alpha *= 0.6;
                        } else if (this.effects.speed) {
                            // Speed effect - add motion blur
                            ctx.shadowColor = '#00BFFF';
                            ctx.shadowBlur = 10;
                        }
                        
                        ctx.fillStyle = i % 3 === 0 
                            ? this.color 
                            : `rgba(255, 255, 255, ${alpha})`;
                    }
                    ctx.fill();
                    
                    // Reset shadow
                    ctx.shadowBlur = 0;
                    
                    // Draw eyes on head
                    if (i === 0) {
                        // Left eye
                        const leftEyeX = segment.x + Math.cos(this.angle - 0.3) * (size * 0.7);
                        const leftEyeY = segment.y + Math.sin(this.angle - 0.3) * (size * 0.7);
                        
                        // Right eye
                        const rightEyeX = segment.x + Math.cos(this.angle + 0.3) * (size * 0.7);
                        const rightEyeY = segment.y + Math.sin(this.angle + 0.3) * (size * 0.7);
                        
                        ctx.fillStyle = 'white';
                        ctx.beginPath();
                        ctx.arc(leftEyeX, leftEyeY, size * 0.3, 0, Math.PI * 2);
                        ctx.arc(rightEyeX, rightEyeY, size * 0.3, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Pupils
                        ctx.fillStyle = 'black';
                        ctx.beginPath();
                        ctx.arc(leftEyeX, leftEyeY, size * 0.15, 0, Math.PI * 2);
                        ctx.arc(rightEyeX, rightEyeY, size * 0.15, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // Draw nickname above the snake
                if (this.nickname) {
                    ctx.font = 'bold 14px Poppins';
                    ctx.textAlign = 'center';
                    ctx.fillStyle = 'white';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 3;
                    ctx.strokeText(this.nickname, this.head.x, this.head.y - 25);
                    ctx.fillText(this.nickname, this.head.x, this.head.y - 25);
                }
            }
        }
        
        // Food class
        class Food {
            constructor(x, y, type = null) {
                this.x = x || randomRange(-config.worldSize/2, config.worldSize/2);
                this.y = y || randomRange(-config.worldSize/2, config.worldSize/2);
                this.size = config.foodSize;
                this.type = type || getRandomFoodType();
                this.color = foodTypes[this.type].color || randomColor();
                this.pulseSize = randomRange(0.85, 1.15);
                this.pulseSpeed = randomRange(0.5, 2);
                this.angle = randomRange(0, Math.PI * 2);
                this.rotationAngle = 0;
                this.rotationSpeed = this.type !== 'regular' ? randomRange(0.5, 2) : 0;
            }
            
            update(dt) {
                this.angle += this.pulseSpeed * dt;
                this.pulseSize = 0.85 + 0.15 * Math.sin(this.angle);
                
                // Rotate special foods
                if (this.type !== 'regular') {
                    this.rotationAngle += this.rotationSpeed * dt;
                }
            }
            
            draw(ctx) {
                const size = this.size * this.pulseSize;
                
                // Draw glow
                ctx.beginPath();
                ctx.arc(this.x, this.y, size * 1.5, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${parseInt(this.color.slice(1, 3), 16)}, ${parseInt(this.color.slice(3, 5), 16)}, ${parseInt(this.color.slice(5, 7), 16)}, 0.2)`;
                ctx.fill();
                
                // Draw food pellet
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10;
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // Draw special food indicators
                if (this.type !== 'regular') {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.rotationAngle);
                    
                    switch (this.type) {
                        case 'star':
                            // Draw star shape
                            this.drawStar(ctx, 0, 0, 5, size * 0.8, size * 0.4);
                            break;
                        case 'speed':
                            // Draw lightning bolt
                            this.drawLightning(ctx, 0, 0, size);
                            break;
                        case 'shield':
                            // Draw shield shape
                            this.drawShield(ctx, 0, 0, size);
                            break;
                        case 'ghost':
                            // Draw ghost shape
                            this.drawGhost(ctx, 0, 0, size);
                            break;
                        case 'shrink':
                            // Draw minus sign
                            this.drawMinus(ctx, 0, 0, size);
                            break;
                    }
                    
                    ctx.restore();
                }
            }
            
            // Helper methods to draw special food shapes
            drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
                let rot = Math.PI / 2 * 3;
                let x = cx;
                let y = cy;
                let step = Math.PI / spikes;
                
                ctx.beginPath();
                ctx.moveTo(cx, cy - outerRadius);
                
                for (let i = 0; i < spikes; i++) {
                    x = cx + Math.cos(rot) * outerRadius;
                    y = cy + Math.sin(rot) * outerRadius;
                    ctx.lineTo(x, y);
                    rot += step;
                    
                    x = cx + Math.cos(rot) * innerRadius;
                    y = cy + Math.sin(rot) * innerRadius;
                    ctx.lineTo(x, y);
                    rot += step;
                }
                
                ctx.lineTo(cx, cy - outerRadius);
                ctx.closePath();
                ctx.fillStyle = 'white';
                ctx.fill();
            }
            
            drawLightning(ctx, cx, cy, size) {
                const s = size * 0.6;
                ctx.beginPath();
                ctx.moveTo(cx, cy - s);
                ctx.lineTo(cx + s * 0.3, cy - s * 0.2);
                ctx.lineTo(cx, cy + s * 0.2);
                ctx.lineTo(cx + s * 0.5, cy + s);
                ctx.lineTo(cx + s * 0.2, cy);
                ctx.lineTo(cx + s * 0.5, cy - s * 0.4);
                ctx.closePath();
                ctx.fillStyle = 'white';
                ctx.fill();
            }
            
            drawShield(ctx, cx, cy, size) {
                const s = size * 0.6;
                ctx.beginPath();
                ctx.moveTo(cx, cy - s);
                ctx.quadraticCurveTo(cx + s, cy - s * 0.5, cx + s * 0.8, cy + s * 0.5);
                ctx.quadraticCurveTo(cx, cy + s, cx - s * 0.8, cy + s * 0.5);
                ctx.quadraticCurveTo(cx - s, cy - s * 0.5, cx, cy - s);
                ctx.closePath();
                ctx.fillStyle = 'white';
                ctx.fill();
            }
            
            drawGhost(ctx, cx, cy, size) {
                const s = size * 0.6;
                ctx.beginPath();
                ctx.moveTo(cx - s * 0.7, cy + s * 0.7);
                ctx.lineTo(cx - s * 0.3, cy + s * 0.3);
                ctx.lineTo(cx, cy + s * 0.7);
                ctx.lineTo(cx + s * 0.3, cy + s * 0.3);
                ctx.lineTo(cx + s * 0.7, cy + s * 0.7);
                ctx.quadraticCurveTo(cx + s, cy, cx + s, cy - s * 0.5);
                ctx.arc(cx, cy - s * 0.5, s, 0, Math.PI, true);
                ctx.quadraticCurveTo(cx - s, cy, cx - s * 0.7, cy + s * 0.7);
                ctx.closePath();
                ctx.fillStyle = 'white';
                ctx.fill();
                
                // Eyes
                ctx.beginPath();
                ctx.arc(cx - s * 0.3, cy - s * 0.6, s * 0.2, 0, Math.PI * 2);
                ctx.arc(cx + s * 0.3, cy - s * 0.6, s * 0.2, 0, Math.PI * 2);
                ctx.fillStyle = 'black';
                ctx.fill();
            }
            
            drawMinus(ctx, cx, cy, size) {
                const s = size * 0.6;
                ctx.beginPath();
                ctx.rect(cx - s * 0.7, cy - s * 0.2, s * 1.4, s * 0.4);
                ctx.fillStyle = 'white';
                ctx.fill();
            }
        }
        
        // Initialize game
        function initGame() {
            resizeCanvas();
            updateScoreDisplay();
            
            // Create snake
            snake = new Snake(0, 0, gameState.snakeColor, true, gameState.nickname);
            
            // Generate food
            foods = [];
            for (let i = 0; i < config.foodAmount; i++) {
                foods.push(new Food());
            }
            
            // Initialize other snakes for multiplayer
            otherSnakes = [];
            if (gameState.isMultiplayer) {
                // Show leaderboard in multiplayer
                leaderboard.style.display = 'block';
                
                // Create AI snakes or placeholder for other players
                for (let i = 0; i < Math.min(gameState.players.length, config.maxPlayers - 1); i++) {
                    const player = gameState.players[i];
                    if (player.nickname !== gameState.nickname) {
                        const startX = randomRange(-config.worldSize/4, config.worldSize/4);
                        const startY = randomRange(-config.worldSize/4, config.worldSize/4);
                        otherSnakes.push(new Snake(startX, startY, player.color, false, player.nickname));
                    }
                }
            } else {
                // Hide leaderboard in single player
                leaderboard.style.display = 'none';
            }
            
            // Reset score
            gameState.score = snake.segments.length;
            updateScore(gameState.score);
            
            // Start game loop
            gameState.running = true;
            lastTime = performance.now();
            gameLoop();
        }
        
        // Game loop
        function gameLoop(timestamp) {
            if (!gameState.running) return;
            
            // Calculate delta time
            const dt = (timestamp - lastTime) / 1000; // Convert to seconds
            lastTime = timestamp;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Set camera transform
            ctx.save();
            ctx.translate(canvas.width/2 - camera.x, canvas.height/2 - camera.y);
            
            // Draw grid
            drawGrid();
            
            // Draw world boundary
            drawWorldBoundary();
            
            // Update and draw foods
            foods.forEach((food, index) => {
                food.update(dt);
                
                // Check if food is in view
                const viewBounds = {
                    left: camera.x - canvas.width/2 - 100,
                    right: camera.x + canvas.width/2 + 100,
                    top: camera.y - canvas.height/2 - 100,
                    bottom: camera.y + canvas.height/2 + 100
                };
                
                if (food.x >= viewBounds.left && food.x <= viewBounds.right && 
                    food.y >= viewBounds.top && food.y <= viewBounds.bottom) {
                    food.draw(ctx);
                }
                
                // Check collision with player snake head
                const dx = snake.head.x - food.x;
                const dy = snake.head.y - food.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < snake.segments[0].size + food.size) {
                    // Eat food
                    if (config.sounds && sounds.eat) {
                        sounds.eat.currentTime = 0;
                        sounds.eat.play();
                    }
                    
                    // Apply food effects
                    const foodType = foodTypes[food.type];
                    
                    // Grow snake
                    snake.grow(foodType.growAmount);
                    
                    // Update score with multiplier
                    updateScore(snake.segments.length * foodType.scoreMultiplier);
                    
                    // Apply special effects
                    if (foodType.effect) {
                        activatePowerUp(foodType.effect);
                    }
                    
                    // Replace eaten food
                    foods[index] = new Food();
                }
                
                // Check collision with other snakes in multiplayer
                if (gameState.isMultiplayer) {
                    for (const otherSnake of otherSnakes) {
                        const dx = otherSnake.head.x - food.x;
                        const dy = otherSnake.head.y - food.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < otherSnake.segments[0].size + food.size) {
                            // AI snake eats food
                            const foodType = foodTypes[food.type];
                            
                            // Grow snake
                            otherSnake.grow(foodType.growAmount);
                            
                            // Update score
                            otherSnake.score = otherSnake.segments.length;
                            
                            // Apply special effects to AI snake
                            if (foodType.effect) {
                                otherSnake.effects[foodType.effect] = true;
                                
                                // Clear effect after duration
                                setTimeout(() => {
                                    otherSnake.effects[foodType.effect] = false;
                                }, config.powerUpDuration * 1000);
                            }
                            
                            // Replace eaten food
                            foods[index] = new Food();
                            
                            // Update leaderboard
                            if (gameState.isMultiplayer) {
                                updateLeaderboard();
                            }
                        }
                    }
                }
            });
            
            // Update player snake
            snake.boosting = boosting;
            snake.update(dt, mouseX, mouseY);
            
            // Update other snakes in multiplayer
            if (gameState.isMultiplayer) {
                for (const otherSnake of otherSnakes) {
                    otherSnake.update(dt);
                }
            }
            
            // Check collisions
            if (snake.checkCollision(otherSnakes)) {
                gameOver();
                return;
            }
            
            // Check collisions for other snakes
            if (gameState.isMultiplayer) {
                for (let i = otherSnakes.length - 1; i >= 0; i--) {
                    if (otherSnakes[i].checkCollision([...otherSnakes.slice(0, i), ...otherSnakes.slice(i + 1), snake])) {
                        // AI snake collision
                        otherSnakes.splice(i, 1);
                        
                        // Update leaderboard
                        updateLeaderboard();
                    }
                }
            }
            
            // Draw player snake
            snake.draw(ctx);
            
            // Draw other snakes in multiplayer
            if (gameState.isMultiplayer) {
                for (const otherSnake of otherSnakes) {
                    otherSnake.draw(ctx);
                }
                
                // Update leaderboard periodically
                if (Math.random() < 0.01) { // Approximately every 100 frames
                    updateLeaderboard();
                }
            }
            
            // Restore context
            ctx.restore();
            
            // Next frame
            requestAnimationFrame(gameLoop);
        }
        
        // Activate power-up
        function activatePowerUp(effect) {
            // Clear previous power-up if exists
            if (gameState.activePowerUp) {
                snake.effects[gameState.activePowerUp] = false;
                clearTimeout(gameState.powerUpTimer);
            }
            
            // Set new power-up
            gameState.activePowerUp = effect;
            snake.effects[effect] = true;
            
            // Play power-up sound
            if (config.sounds && sounds.powerUp) {
                sounds.powerUp.currentTime = 0;
                sounds.powerUp.play();
            }
            
            // Show power-up indicator
            powerUpIcon.innerHTML = getPowerUpIcon(effect);
            powerUpText.textContent = getPowerUpText(effect);
            powerUpIndicator.style.opacity = '1';
            
            // Set timer to deactivate power-up
            gameState.powerUpTimer = setTimeout(() => {
                snake.effects[effect] = false;
                gameState.activePowerUp = null;
                powerUpIndicator.style.opacity = '0';
                
                // Play power-down sound
                if (config.sounds && sounds.powerDown) {
                    sounds.powerDown.currentTime = 0;
                    sounds.powerDown.play();
                }
            }, config.powerUpDuration * 1000);
        }
        
        // Get power-up icon
        function getPowerUpIcon(effect) {
            switch (effect) {
                case 'speed': return '<i class="fas fa-bolt"></i>';
                case 'shield': return '<i class="fas fa-shield-alt"></i>';
                case 'ghost': return '<i class="fas fa-ghost"></i>';
                default: return '<i class="fas fa-star"></i>';
            }
        }
        
        // Get power-up text
        function getPowerUpText(effect) {
            switch (effect) {
                case 'speed': return 'Speed Boost Active!';
                case 'shield': return 'Shield Active!';
                case 'ghost': return 'Ghost Mode Active!';
                default: return 'Power-Up Active!';
            }
        }
        
        // Update leaderboard
        function updateLeaderboard() {
            if (!gameState.isMultiplayer) return;
            
            // Collect all snakes
            const allSnakes = [snake, ...otherSnakes];
            
            // Sort by score (length)
            allSnakes.sort((a, b) => b.score - a.score);
            
            // Update leaderboard UI
            leaderboardItems.innerHTML = '';
            
            for (let i = 0; i < Math.min(allSnakes.length, 5); i++) {
                const snakeItem = allSnakes[i];
                const item = document.createElement('div');
                item.className = 'leaderboard-item';
                
                // Highlight player's snake
                if (snakeItem === snake) {
                    item.style.fontWeight = 'bold';
                }
                
                item.innerHTML = `
                    <span>${i + 1}. ${snakeItem.nickname}</span>
                    <span>${snakeItem.score}</span>
                `;
                
                leaderboardItems.appendChild(item);
            }
        }
        
        // Draw grid
        function drawGrid() {
            const gridSize = config.gridSize;
            const startX = Math.floor((camera.x - canvas.width/2) / gridSize) * gridSize;
            const startY = Math.floor((camera.y - canvas.height/2) / gridSize) * gridSize;
            const endX = startX + canvas.width + gridSize * 2;
            const endY = startY + canvas.height + gridSize * 2;
            
            ctx.strokeStyle = 'rgba(100, 100, 150, 0.15)';
            ctx.lineWidth = 1;
            
            // Vertical lines
            for (let x = startX; x < endX; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, startY);
                ctx.lineTo(x, endY);
                ctx.stroke();
            }
            
            // Horizontal lines
            for (let y = startY; y < endY; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(startX, y);
                ctx.lineTo(endX, y);
                ctx.stroke();
            }
        }
        
        // Draw world boundary
        function drawWorldBoundary() {
            const halfSize = config.worldSize / 2;
            
            // Draw boundary
            ctx.strokeStyle = 'rgba(255, 100, 100, 0.8)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.rect(-halfSize, -halfSize, config.worldSize, config.worldSize);
            ctx.stroke();
            
            // Add warning pattern near edges
            const warningWidth = 30;
            ctx.strokeStyle = 'rgba(255, 100, 100, 0.5)';
            ctx.lineWidth = warningWidth;
            ctx.beginPath();
            ctx.rect(
                -halfSize + warningWidth/2, 
                -halfSize + warningWidth/2, 
                config.worldSize - warningWidth, 
                config.worldSize - warningWidth
            );
            ctx.stroke();
        }
        
        // Update score
        function updateScore(newScore) {
            gameState.score = newScore;
            currentScoreElement.textContent = gameState.score;
            
            // Update best score if needed
            if (gameState.score > gameState.bestScore) {
                gameState.bestScore = gameState.score;
                localStorage.setItem('snakeArenaBestScore', gameState.bestScore);
                updateScoreDisplay();
            }
        }
        
        // Update score display elements
        function updateScoreDisplay() {
            bestScoreElement.textContent = gameState.bestScore;
            bestScoreFinalElement.textContent = gameState.bestScore;
        }
        
        // Game over
        function gameOver() {
            gameState.running = false;
            
            if (config.sounds && sounds.gameOver) {
                sounds.gameOver.currentTime = 0;
                sounds.gameOver.play();
            }
            
            // Clear any active power-ups
            if (gameState.activePowerUp) {
                snake.effects[gameState.activePowerUp] = false;
                clearTimeout(gameState.powerUpTimer);
                gameState.activePowerUp = null;
                powerUpIndicator.style.opacity = '0';
            }
            
            finalScoreElement.textContent = gameState.score;
            gameScreen.style.display = 'none';
            gameOverScreen.style.display = 'flex';
        }
        
        // Initialize multiplayer lobby
        function initMultiplayerLobby() {
            // Reset players list
            gameState.players = [];
            
            // Add current player
            gameState.players.push({
                nickname: gameState.nickname,
                color: gameState.snakeColor,
                isReady: false
            });
            
            // Add some AI players
            const aiNames = ['Bot_Alpha', 'Bot_Beta', 'Bot_Gamma', 'Bot_Delta', 'Bot_Epsilon'];
            const aiColors = ['#ef4444', '#22c55e', '#eab308', '#a855f7', '#ec4899'];
            
            for (let i = 0; i < 3; i++) {
                gameState.players.push({
                    nickname: aiNames[i],
                    color: aiColors[i],
                    isReady: false
                });
            }
            
            // Update player list UI
            updatePlayerList();
            
            // Show multiplayer lobby
            homeScreen.style.display = 'none';
            multiplayerLobby.style.display = 'flex';
        }
        
        // Update player list in lobby
        function updatePlayerList() {
            playerList.innerHTML = '';
            
            for (const player of gameState.players) {
                const playerItem = document.createElement('div');
                playerItem.className = 'player-item';
                
                playerItem.innerHTML = `
                    <div class="player-color" style="background-color: ${player.color}"></div>
                    <div class="flex-1">${player.nickname}</div>
                    <div>${player.isReady ? '<i class="fas fa-check text-green-500"></i>' : '<i class="fas fa-clock text-yellow-500"></i>'}</div>
                `;
                
                playerList.appendChild(playerItem);
            }
        }
        
        // Start multiplayer game
        function startMultiplayerGame() {
            // Mark all players as ready
            for (let player of gameState.players) {
                player.isReady = true;
            }
            
            // Update player list one last time
            updatePlayerList();
            
            // Set multiplayer flag
            gameState.isMultiplayer = true;
            
            // Hide lobby and show game
            multiplayerLobby.style.display = 'none';
            gameScreen.style.display = 'block';
            
            // Initialize game
            initGame();
        }
        
        // Event Listeners
        let mouseX = 0;
        let mouseY = 0;
        
        // Mouse move event
        canvas.addEventListener('mousemove', function(e) {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        
        // Touch move event (for mobile)
        canvas.addEventListener('touchmove', function(e) {
            e.preventDefault();
            mouseX = e.touches[0].clientX;
            mouseY = e.touches[0].clientY;
        });
        
        // Key events
        window.addEventListener('keydown', function(e) {
            keys[e.code] = true;
            
            if (e.code === 'Space') {
                boosting = true;
                
                if (config.sounds && sounds.boost) {
                    sounds.boost.currentTime = 0;
                    sounds.boost.play();
                }
                
                e.preventDefault();
            }
        });
        
        window.addEventListener('keyup', function(e) {
            keys[e.code] = false;
            
            if (e.code === 'Space') {
                boosting = false;
                e.preventDefault();
            }
        });
        
        // Resize event
        window.addEventListener('resize', resizeCanvas);
        
        // Play button
        playBtn.addEventListener('click', function() {
            gameState.nickname = nicknameInput.value.trim() || "Player";
            
            // Get selected game mode
            for (const option of gameModeOptions) {
                if (option.checked) {
                    gameState.gameMode = option.value;
                    break;
                }
            }
            
            if (gameState.gameMode === 'multi') {
                // Initialize multiplayer lobby
                initMultiplayerLobby();
            } else {
                // Start single player game
                gameState.isMultiplayer = false;
                homeScreen.style.display = 'none';
                gameScreen.style.display = 'block';
                initGame();
            }
        });
        
        // Play again button
        playAgainBtn.addEventListener('click', function() {
            gameOverScreen.style.display = 'none';
            gameScreen.style.display = 'block';
            initGame();
        });
        
        // Home button
        homeBtn.addEventListener('click', function() {
            gameOverScreen.style.display = 'none';
            homeScreen.style.display = 'flex';
        });
        
        // Start multiplayer button
        startMultiplayerBtn.addEventListener('click', function() {
            startMultiplayerGame();
        });
        
        // Leave lobby button
        leaveLobbyBtn.addEventListener('click', function() {
            multiplayerLobby.style.display = 'none';
            homeScreen.style.display = 'flex';
        });
        
        // Sound toggle
        soundToggle.addEventListener('click', function() {
            config.sounds = !config.sounds;
            soundToggle.innerHTML = config.sounds ? 
                '<i class="fas fa-volume-up"></i>' : 
                '<i class="fas fa-volume-mute"></i>';
        });
        
        // Color selection
        colorOptions.forEach(option => {
            option.addEventListener('click', function() {
                // Remove active class from all options
                colorOptions.forEach(opt => opt.classList.remove('ring-4', 'ring-white'));
                
                // Add active class to selected option
                this.classList.add('ring-4', 'ring-white');
                
                // Set snake color
                gameState.snakeColor = this.dataset.color;
            });
        });
        
        // Page navigation
        document.querySelectorAll('.nav-link[data-page]').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const pageId = this.dataset.page;
                const pageElement = document.getElementById(`${pageId}-page`);
                
                if (pageElement) {
                    // Hide all content pages
                    document.querySelectorAll('.content-page').forEach(page => {
                        page.style.display = 'none';
                    });
                    
                    // Show selected page
                    pageElement.style.display = 'block';
                }
            });
        });
        
        // Home link
        document.querySelectorAll('.home-link').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                // Hide all content pages
                document.querySelectorAll('.content-page').forEach(page => {
                    page.style.display = 'none';
                });
            });
        });
        
        // Close buttons
        document.querySelectorAll('.close-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                this.parentElement.style.display = 'none';
            });
        });
        
        // Contact form submission
        const contactForm = document.getElementById('contact-form');
        const contactSuccess = document.getElementById('contact-success');
        
        if (contactForm) {
            contactForm.addEventListener('submit', function(e) {
                e.preventDefault();
                // In a real implementation, you would send the form data to a server
                // For now, just show success message
                contactForm.reset();
                contactSuccess.classList.remove('hidden');
                
                // Hide success message after 3 seconds
                setTimeout(() => {
                    contactSuccess.classList.add('hidden');
                }, 3000);
            });
        }
        
        // Initialize best score from localStorage
        bestScoreElement.textContent = gameState.bestScore;
    </script>
</body>
</html>
